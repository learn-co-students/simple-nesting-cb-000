
def hopper
	programmer_hash =
 		{
        :grace_hopper => {
          :known_for => "COBOL",
          :languages => ["COBOL", "FORTRAN"]
        },
        :alan_kay => {
          :known_for => "Object Orientation",
          :languages => ["Smalltalk", "LISP"]
        },
        :dennis_ritchie => {
          :known_for => "Unix",
          :languages => ["C"]
        }
     }
  # 1) nested hash #hopper operates on the programmer_hash and returns the value of the :grace_hopper key
	programmer_hash[:grace_hopper]
end #hopper

def alan_kay_is_known_for
	# What combination of keys would you use to return the value of the :known_for key of :alan_kay?

	programmer_hash =
 		{
        :grace_hopper => {
          :known_for => "COBOL",
          :languages => ["COBOL", "FORTRAN"]
        },
        :alan_kay => {
          :known_for => "Object Orientation",
          :languages => ["Smalltalk", "LISP"]
        },
        :dennis_ritchie => {
          :known_for => "Unix",
          :languages => ["C"]
        }
     }
#  1) nested hash #alan_kay_is_known_for operates on the programmer_hash and returns the value of what Alan Kay is known for
	programmer_hash[:alan_kay][:known_for]
end #alan_kay_is_known_for

def dennis_ritchies_language
	programmer_hash =
 		{
        :grace_hopper => {
          :known_for => "COBOL",
          :languages => ["COBOL", "FORTRAN"]
        },
        :alan_kay => {
          :known_for => "Object Orientation",
          :languages => ["Smalltalk", "LISP"]
        },
        :dennis_ritchie => {
          :known_for => "Unix",
          :languages => ["C"]
        }
     }
  # 1) nested hash #dennis_ritchies_language operates on the programmer_hash and
	# returns the value of Dennis Ritchie's language as a string
programmer_hash[:dennis_ritchie][:languages].join
end #dennis_ritchie

def adding_matz
# add the following information to the top level of programmer_hash
	programmer_hash =
 		{
        :grace_hopper => {
          :known_for => "COBOL",
          :languages => ["COBOL", "FORTRAN"]
        },
        :alan_kay => {
          :known_for => "Object Orientation",
          :languages => ["Smalltalk", "LISP"]
        },
        :dennis_ritchie => {
          :known_for => "Unix",
          :languages => ["C"]
        }
     }
		#  1) nested hash #adding_matz operates on the programmer_hash and adds a key/value pair to the top level of the hash,
		#   returning the newly-added-to hash
		# programmer_hash[:yukihiro_matsumoto] => {
		programmer_hash[:yukihiro_matsumoto] = {
		  :known_for => "Ruby",
		   :languages => ["LISP", "C"]
		}

		programmer_hash
end #adding_matz

def changing_alan
	programmer_hash =
 		{
        :grace_hopper => {
          :known_for => "COBOL",
          :languages => ["COBOL", "FORTRAN"]
        },
        :alan_kay => {
          :known_for => "Object Orientation",
          :languages => ["Smalltalk", "LISP"]
        },
        :dennis_ritchie => {
          :known_for => "Unix",
          :languages => ["C"]
        }
     }
     #change what Alan Kay is :known_for to the value of the alans_new_info variable.
     alans_new_info = "GUI"

		 programmer_hash[:alan_kay][:known_for]=alans_new_info
		 programmer_hash
end #changing_alan

def adding_to_dennis
	programmer_hash =
 		{
        :grace_hopper => {
          :known_for => "COBOL",
          :languages => ["COBOL", "FORTRAN"]
        },
        :alan_kay => {
          :known_for => "Object Orientation",
          :languages => ["Smalltalk", "LISP"]
        },
        :dennis_ritchie => {
          :known_for => "Unix",
          :languages => ["C"]
        }
     }
 programmer_hash[:dennis_ritchie][:languages] << "Assembly"
 programmer_hash
end
